#!/usr/bin/env python3

from datetime import datetime
import argparse
import json
import os
import random
import re
import subprocess
import sys


def do_backup(repo_info, conf):
    repo = repo_info['repo']
    passphrase = repo_info.get('passphrase')
    prefix = conf['prefix']
    prefix_glob = conf['prefix-glob']
    keep = conf['keep']

    timestamp = datetime.now().astimezone().strftime('%FT%T%z')
    create_cmd = [
        'create',
        '--progress',
        '--stats',
        f'{repo}::{prefix}{timestamp}',
    ] + conf['paths']
    borg_cmd(*create_cmd, passphrase=passphrase)

    borg_cmd(
        'prune',
        repo,
        '--glob-archives',
        prefix_glob,
        '--stats',
        f'--keep-within={keep["within"]}',
        f'--keep-daily={keep["daily"]}',
        f'--keep-weekly={keep["weekly"]}',
        f'--keep-monthly={keep["monthly"]}',
        f'--keep-yearly={keep["yearly"]}',
        passphrase=passphrase
    )


def get_ssid():
    getssid_path = os.path.join(os.path.dirname(__file__), 'getssid')
    out = subprocess.check_output([getssid_path]).decode('utf8').strip()
    if out == 'missing value':
        return None
    return out


def borg_cmd(*cmd, passphrase=None):
    cmd = ('borg',) + cmd
    if passphrase is not None:
        read_fd, write_fd = os.pipe()
        env = dict(os.environ)
        env['BORG_PASSPHRASE_FD'] = str(read_fd)
        # POSIX requires pipe buffer to be at least 512 bytes, so it's fine to do a
        # blocking write here before there is anyone reading
        os.write(write_fd, passphrase.encode('utf8'))
        os.close(write_fd)  # EOF
        subprocess.check_call(cmd, pass_fds=(sys.stdout.fileno(), sys.stderr.fileno(), read_fd), env=env)
        os.close(read_fd)
    else:
        subprocess.check_call(cmd, pass_fds=(sys.stdout.fileno(), sys.stderr.fileno()))


def main():
    parser = argparse.ArgumentParser(description='Perform Borg backup based on configuration')
    parser.add_argument('config_file', help='Path to the configuration file')
    parser.add_argument('--ssid', help='Override the current SSID')
    parser.add_argument('--repo', help='Select a specific repo by name')
    args = parser.parse_args()

    with open(args.config_file) as f:
        conf = json.load(f)

    if args.repo:
        # If repo is specified, find it by name
        eligible_repos = [r for r in conf['repos'] if r['name'] == args.repo]
        if not eligible_repos:
            print(f'No repo found with name "{args.repo}"', file=sys.stderr)
            exit(1)
        repo_info = eligible_repos[0]
    else:
        # Otherwise use SSID-based selection
        ssid = args.ssid if args.ssid is not None else get_ssid()
        if ssid is None:
            print(f'Not connected to a WiFi network', file=sys.stderr)
            exit(1)

        eligible_repos = [r for r in conf['repos'] if ssid in r['ssids']]
        if not eligible_repos:
            print(f'No backup configuration for SSID "{ssid}"', file=sys.stderr)
            exit(1)
        print(f'Eligible repos: {", ".join(r["name"] for r in eligible_repos)}', file=sys.stderr)
        repo_info = random.choice(eligible_repos)

    print(f'Backing up to {repo_info["name"]} ({repo_info["repo"]})', file=sys.stderr)

    sys.stderr.flush()
    del conf['repos']
    do_backup(repo_info, conf)


if __name__ == '__main__':
    main()
